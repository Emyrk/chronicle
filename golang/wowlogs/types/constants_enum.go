// Code generated by go-enum DO NOT EDIT.
// Version: v0.9.2

// Built By: go install

package types

import (
	"errors"
	"fmt"
	"strings"
)

const (
	// AuraApplicationUnknown is a AuraApplication of type Unknown.
	AuraApplicationUnknown AuraApplication = "Unknown"
	// AuraApplicationGains is a AuraApplication of type Gains.
	AuraApplicationGains AuraApplication = "Gains"
	// AuraApplicationFades is a AuraApplication of type Fades.
	AuraApplicationFades AuraApplication = "Fades"
	// AuraApplicationRemoved is a AuraApplication of type Removed.
	AuraApplicationRemoved AuraApplication = "Removed"
)

var ErrInvalidAuraApplication = errors.New("not a valid AuraApplication")

// String implements the Stringer interface.
func (x AuraApplication) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x AuraApplication) IsValid() bool {
	_, err := ParseAuraApplication(string(x))
	return err == nil
}

var _AuraApplicationValue = map[string]AuraApplication{
	"Unknown": AuraApplicationUnknown,
	"unknown": AuraApplicationUnknown,
	"Gains":   AuraApplicationGains,
	"gains":   AuraApplicationGains,
	"Fades":   AuraApplicationFades,
	"fades":   AuraApplicationFades,
	"Removed": AuraApplicationRemoved,
	"removed": AuraApplicationRemoved,
}

// ParseAuraApplication attempts to convert a string to a AuraApplication.
func ParseAuraApplication(name string) (AuraApplication, error) {
	if x, ok := _AuraApplicationValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _AuraApplicationValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return AuraApplication(""), fmt.Errorf("%s is %w", name, ErrInvalidAuraApplication)
}

const (
	// CastActionsCasts is a CastActions of type casts.
	CastActionsCasts CastActions = "casts"
	// CastActionsBeginsToCast is a CastActions of type begins to cast.
	CastActionsBeginsToCast CastActions = "begins to cast"
	// CastActionsChannels is a CastActions of type channels.
	CastActionsChannels CastActions = "channels"
	// CastActionsFailsCasting is a CastActions of type fails casting.
	CastActionsFailsCasting CastActions = "fails casting"
)

var ErrInvalidCastActions = errors.New("not a valid CastActions")

// String implements the Stringer interface.
func (x CastActions) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x CastActions) IsValid() bool {
	_, err := ParseCastActions(string(x))
	return err == nil
}

var _CastActionsValue = map[string]CastActions{
	"casts":          CastActionsCasts,
	"begins to cast": CastActionsBeginsToCast,
	"channels":       CastActionsChannels,
	"fails casting":  CastActionsFailsCasting,
}

// ParseCastActions attempts to convert a string to a CastActions.
func ParseCastActions(name string) (CastActions, error) {
	if x, ok := _CastActionsValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _CastActionsValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return CastActions(""), fmt.Errorf("%s is %w", name, ErrInvalidCastActions)
}

const (
	// HeroClassesDRUID is a HeroClasses of type DRUID.
	HeroClassesDRUID HeroClasses = "DRUID"
	// HeroClassesHUNTER is a HeroClasses of type HUNTER.
	HeroClassesHUNTER HeroClasses = "HUNTER"
	// HeroClassesMAGE is a HeroClasses of type MAGE.
	HeroClassesMAGE HeroClasses = "MAGE"
	// HeroClassesPALADIN is a HeroClasses of type PALADIN.
	HeroClassesPALADIN HeroClasses = "PALADIN"
	// HeroClassesPRIEST is a HeroClasses of type PRIEST.
	HeroClassesPRIEST HeroClasses = "PRIEST"
	// HeroClassesROGUE is a HeroClasses of type ROGUE.
	HeroClassesROGUE HeroClasses = "ROGUE"
	// HeroClassesSHAMAN is a HeroClasses of type SHAMAN.
	HeroClassesSHAMAN HeroClasses = "SHAMAN"
	// HeroClassesWARLOCK is a HeroClasses of type WARLOCK.
	HeroClassesWARLOCK HeroClasses = "WARLOCK"
	// HeroClassesWARRIOR is a HeroClasses of type WARRIOR.
	HeroClassesWARRIOR HeroClasses = "WARRIOR"
)

var ErrInvalidHeroClasses = errors.New("not a valid HeroClasses")

// String implements the Stringer interface.
func (x HeroClasses) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x HeroClasses) IsValid() bool {
	_, err := ParseHeroClasses(string(x))
	return err == nil
}

var _HeroClassesValue = map[string]HeroClasses{
	"DRUID":   HeroClassesDRUID,
	"druid":   HeroClassesDRUID,
	"HUNTER":  HeroClassesHUNTER,
	"hunter":  HeroClassesHUNTER,
	"MAGE":    HeroClassesMAGE,
	"mage":    HeroClassesMAGE,
	"PALADIN": HeroClassesPALADIN,
	"paladin": HeroClassesPALADIN,
	"PRIEST":  HeroClassesPRIEST,
	"priest":  HeroClassesPRIEST,
	"ROGUE":   HeroClassesROGUE,
	"rogue":   HeroClassesROGUE,
	"SHAMAN":  HeroClassesSHAMAN,
	"shaman":  HeroClassesSHAMAN,
	"WARLOCK": HeroClassesWARLOCK,
	"warlock": HeroClassesWARLOCK,
	"WARRIOR": HeroClassesWARRIOR,
	"warrior": HeroClassesWARRIOR,
}

// ParseHeroClasses attempts to convert a string to a HeroClasses.
func ParseHeroClasses(name string) (HeroClasses, error) {
	if x, ok := _HeroClassesValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _HeroClassesValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return HeroClasses(""), fmt.Errorf("%s is %w", name, ErrInvalidHeroClasses)
}

const (
	// HeroGenderNotSet is a HeroGender of type NotSet.
	HeroGenderNotSet HeroGender = iota
	// HeroGenderUnknown is a HeroGender of type Unknown.
	HeroGenderUnknown
	// HeroGenderMale is a HeroGender of type Male.
	HeroGenderMale
	// HeroGenderFemale is a HeroGender of type Female.
	HeroGenderFemale
)

var ErrInvalidHeroGender = errors.New("not a valid HeroGender")

const _HeroGenderName = "NotSetUnknownMaleFemale"

var _HeroGenderMap = map[HeroGender]string{
	HeroGenderNotSet:  _HeroGenderName[0:6],
	HeroGenderUnknown: _HeroGenderName[6:13],
	HeroGenderMale:    _HeroGenderName[13:17],
	HeroGenderFemale:  _HeroGenderName[17:23],
}

// String implements the Stringer interface.
func (x HeroGender) String() string {
	if str, ok := _HeroGenderMap[x]; ok {
		return str
	}
	return fmt.Sprintf("HeroGender(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x HeroGender) IsValid() bool {
	_, ok := _HeroGenderMap[x]
	return ok
}

var _HeroGenderValue = map[string]HeroGender{
	_HeroGenderName[0:6]:                    HeroGenderNotSet,
	strings.ToLower(_HeroGenderName[0:6]):   HeroGenderNotSet,
	_HeroGenderName[6:13]:                   HeroGenderUnknown,
	strings.ToLower(_HeroGenderName[6:13]):  HeroGenderUnknown,
	_HeroGenderName[13:17]:                  HeroGenderMale,
	strings.ToLower(_HeroGenderName[13:17]): HeroGenderMale,
	_HeroGenderName[17:23]:                  HeroGenderFemale,
	strings.ToLower(_HeroGenderName[17:23]): HeroGenderFemale,
}

// ParseHeroGender attempts to convert a string to a HeroGender.
func ParseHeroGender(name string) (HeroGender, error) {
	if x, ok := _HeroGenderValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _HeroGenderValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return HeroGender(0), fmt.Errorf("%s is %w", name, ErrInvalidHeroGender)
}

const (
	// HeroRacesScourge is a HeroRaces of type Scourge.
	HeroRacesScourge HeroRaces = "Scourge"
	// HeroRacesOrc is a HeroRaces of type Orc.
	HeroRacesOrc HeroRaces = "Orc"
	// HeroRacesTroll is a HeroRaces of type Troll.
	HeroRacesTroll HeroRaces = "Troll"
	// HeroRacesTauren is a HeroRaces of type Tauren.
	HeroRacesTauren HeroRaces = "Tauren"
	// HeroRacesGoblin is a HeroRaces of type Goblin.
	HeroRacesGoblin HeroRaces = "Goblin"
	// HeroRacesHuman is a HeroRaces of type Human.
	HeroRacesHuman HeroRaces = "Human"
	// HeroRacesGnome is a HeroRaces of type Gnome.
	HeroRacesGnome HeroRaces = "Gnome"
	// HeroRacesDwarf is a HeroRaces of type Dwarf.
	HeroRacesDwarf HeroRaces = "Dwarf"
	// HeroRacesNightElf is a HeroRaces of type NightElf.
	HeroRacesNightElf HeroRaces = "NightElf"
	// HeroRacesBloodElf is a HeroRaces of type BloodElf.
	HeroRacesBloodElf HeroRaces = "BloodElf"
)

var ErrInvalidHeroRaces = errors.New("not a valid HeroRaces")

// String implements the Stringer interface.
func (x HeroRaces) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x HeroRaces) IsValid() bool {
	_, err := ParseHeroRaces(string(x))
	return err == nil
}

var _HeroRacesValue = map[string]HeroRaces{
	"Scourge":  HeroRacesScourge,
	"scourge":  HeroRacesScourge,
	"Orc":      HeroRacesOrc,
	"orc":      HeroRacesOrc,
	"Troll":    HeroRacesTroll,
	"troll":    HeroRacesTroll,
	"Tauren":   HeroRacesTauren,
	"tauren":   HeroRacesTauren,
	"Goblin":   HeroRacesGoblin,
	"goblin":   HeroRacesGoblin,
	"Human":    HeroRacesHuman,
	"human":    HeroRacesHuman,
	"Gnome":    HeroRacesGnome,
	"gnome":    HeroRacesGnome,
	"Dwarf":    HeroRacesDwarf,
	"dwarf":    HeroRacesDwarf,
	"NightElf": HeroRacesNightElf,
	"nightelf": HeroRacesNightElf,
	"BloodElf": HeroRacesBloodElf,
	"bloodelf": HeroRacesBloodElf,
}

// ParseHeroRaces attempts to convert a string to a HeroRaces.
func ParseHeroRaces(name string) (HeroRaces, error) {
	if x, ok := _HeroRacesValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _HeroRacesValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return HeroRaces(""), fmt.Errorf("%s is %w", name, ErrInvalidHeroRaces)
}

const (
	// ResourceHealth is a Resource of type Health.
	ResourceHealth Resource = "Health"
	// ResourceMana is a Resource of type Mana.
	ResourceMana Resource = "Mana"
	// ResourceRage is a Resource of type Rage.
	ResourceRage Resource = "Rage"
	// ResourceHappiness is a Resource of type Happiness.
	ResourceHappiness Resource = "Happiness"
	// ResourceEnergy is a Resource of type Energy.
	ResourceEnergy Resource = "Energy"
	// ResourceFocus is a Resource of type Focus.
	ResourceFocus Resource = "Focus"
)

var ErrInvalidResource = errors.New("not a valid Resource")

// String implements the Stringer interface.
func (x Resource) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x Resource) IsValid() bool {
	_, err := ParseResource(string(x))
	return err == nil
}

var _ResourceValue = map[string]Resource{
	"Health":    ResourceHealth,
	"health":    ResourceHealth,
	"Mana":      ResourceMana,
	"mana":      ResourceMana,
	"Rage":      ResourceRage,
	"rage":      ResourceRage,
	"Happiness": ResourceHappiness,
	"happiness": ResourceHappiness,
	"Energy":    ResourceEnergy,
	"energy":    ResourceEnergy,
	"Focus":     ResourceFocus,
	"focus":     ResourceFocus,
}

// ParseResource attempts to convert a string to a Resource.
func ParseResource(name string) (Resource, error) {
	if x, ok := _ResourceValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _ResourceValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return Resource(""), fmt.Errorf("%s is %w", name, ErrInvalidResource)
}
